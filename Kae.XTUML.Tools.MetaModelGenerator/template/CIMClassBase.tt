<#
  // Copyright (c) Knowledge & Experience. All rights reserved.
  // Licensed under the MIT license. See LICENSE file in the project root for full license information.
#>
<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This file is generated by tool.
//     Runtime Version : <#= version #>
//  
//     Updates this file cause incorrect behavior 
//     and will be lost when the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
using System.Linq;
using System.Collections.Generic;

namespace Kae.CIM.MetaModel.CIMofCIM
{
<#
    var logicIndent = "            ";
    foreach (var ck in repository.Classes.Keys)
    {
        var classDef = repository.Classes[ck];
        var interfaceName = RuleOfNamesForTransfrom.GetCIMInterfaceClassName(classDef);
        var className = RuleOfNamesForTransfrom.GetCIMBaseClassName(classDef);
#>
    public class <#= className #> : <#= cimAbstractClassDefClassName #>, <#= interfaceName #>
    {
<#
        
        foreach (var attrName in classDef.Attributes.Keys)
        {
            var attrTypeName = repository.DataTypes[classDef.Attributes[attrName]].CodeTypeName;
            var attrPropertyName = RuleOfNamesForTransfrom.GetAttrPropertyName(attrName);
#>
        public <#= attrTypeName #> <#= attrPropertyName #> { get; set; }
<#
        }
        string constructorAttrArgs = BuildConstructorAttrArgs(classDef);
        string attrDictionary = "attrArgs";
        string constructorAttrDictArgs = BuildThisConstructorAttrArgs(classDef, attrDictionary);
#>

        public <#= className #>(<#= ciModelRepsositoryClassName #> repository, <#= constructorAttrArgs #> ) : base(repository, "<#= classDef.Name #>")
        {
            ;
        }

        public <#= className #>(<#= ciModelRepsositoryClassName #> repository, IDictionary<string, object><#= attrDictionary #> ) : this(repository, <#= constructorAttrDictArgs #>)
        {
            ;
        }

        public void Dispose()
        {
            ;
        }

        public bool Validate()
        {
            return true;
        }

<#

        var binaryRels = repository.Relationships.Values.Where(r => r.Kind == XTUMLOOAofOOA.KindOfRelatioship.Binary);
        var superSubRels = repository.Relationships.Values.Where(r => r.Kind == XTUMLOOAofOOA.KindOfRelatioship.SuperSub);
        var relObjRels = repository.Relationships.Values.Where(r => r.Kind == XTUMLOOAofOOA.KindOfRelatioship.RelationshipClass);

        var binaryRelFrom = binaryRels.Where(r => r.FromEdge.Edge.Name == ck);
        foreach (var brel in binaryRelFrom)
        {
            var linkedToTypeName = RuleOfNamesForTransfrom.GetLinkedMethodReturnTypeName(brel, RuleOfNamesForTransfrom.RelationshipEdgeSide.To);
            var linkedToMethodName = RuleOfNamesForTransfrom.GetLinkedMethodName(brel, RuleOfNamesForTransfrom.RelationshipEdgeSide.To);
#>
        public <#= linkedToTypeName #> <#= linkedToMethodName #>()
        {
<#

            var logicGenerator = new LinkedItemLogic(logicIndent, brel, brel.FromEdge, brel.ToEdge, null);
            var logic = logicGenerator.TransformText();
#>
<#= logic #>
        }

<#
        }

        var binaryRelTo = binaryRels.Where(r => r.ToEdge.Edge.Name == ck);
        foreach (var brel in binaryRelTo)
        {
            var linkedFromTypeName = RuleOfNamesForTransfrom.GetLinkedMethodReturnTypeName(brel, RuleOfNamesForTransfrom.RelationshipEdgeSide.From);
            var linkedFromMethodName = RuleOfNamesForTransfrom.GetLinkedMethodName(brel, RuleOfNamesForTransfrom.RelationshipEdgeSide.From);
#>
        public <#= linkedFromTypeName #> <#= linkedFromMethodName #>()
        {
<#

            var logicGenerator = new LinkedItemLogic(logicIndent, brel, brel.ToEdge, brel.FromEdge, null);
            var logic = logicGenerator.TransformText();
#>
<#= logic #>
        }

<#
        }

        var superSubRelSuper = superSubRels.Where(r => r.ToEdge.Edge.Name == ck);
        foreach (var superrel in superSubRelSuper)
        {
            var subClassName = RuleOfNamesForTransfrom.GetCIMSubClassName(superrel);
            var subClassGetMethodName = RuleOfNamesForTransfrom.GetCIMSubClassMethodName(superrel);
#>
        public <#= subClassName #> <#= subClassGetMethodName #>()
        {
<#

            var ssRel = (XTUMLOOAofOOA.SuperSubRelationshipOfOOA)superrel;

            var logicGenerator = new LinkedItemLogic(logicIndent, superrel, superrel.ToEdge, null, ssRel.SubEdges);
            var logic = logicGenerator.TransformText();
#>
<#= logic #>
        }

<#
        }

        foreach (var ssRel in superSubRels)
        {
            var ssRelC = (XTUMLOOAofOOA.SuperSubRelationshipOfOOA)ssRel;
            var superSubRelSub = ssRelC.SubEdges.Where(r => r.Edge.Name == ck);
            foreach (var subrel in superSubRelSub)
            {
                var superClassName = RuleOfNamesForTransfrom.GetCIMInterfaceClassName(ssRel.ToEdge.Edge);
                var getSuperClassMethodName = RuleOfNamesForTransfrom.GetCIMSuperClassMethodName(ssRel.ToEdge.Edge);
#>
        public <#= superClassName #> <#= getSuperClassMethodName #>()
        {
<#
                var logicGenerator = new LinkedItemLogic(logicIndent, ssRel, subrel, ssRel.ToEdge, null);
                var logic = logicGenerator.TransformText();
#>
<#= logic #>
        }
<#
            }
        }

        var relObjRelOne = relObjRels.Where(r => ((XTUMLOOAofOOA.RelationshipClassRelationOfOOA)r).OneSideEdge.Edge.Name == ck);
        foreach (var onerel in relObjRelOne)
        {
            var relobjrel = (XTUMLOOAofOOA.RelationshipClassRelationOfOOA)onerel;
            var linkedOtherTypeName = RuleOfNamesForTransfrom.GetMethodReturnType(relobjrel.RelationshipClass, relobjrel.RelationshipClass.OneSideEdge.Mult);
            var linkedOtherMethodName = RuleOfNamesForTransfrom.GetLinkedOOMethodName(relobjrel, RuleOfNamesForTransfrom.RelationshipEdgeSide.OtherSide);
#>
        public <#= linkedOtherTypeName #> <#= linkedOtherMethodName #>()
        {
<#
            var logicGenerator = new LinkedItemLogic(logicIndent, onerel, relobjrel.OneSideEdge, relobjrel.RelationshipClass.OneSideEdge, null);
            var logic = logicGenerator.TransformText();
#>
<#= logic #>
        }

<#
        }


        var relObjRelOther = relObjRels.Where(r => ((XTUMLOOAofOOA.RelationshipClassRelationOfOOA)r).OtherSideEdge.Edge.Name == ck);
        foreach (var otherrel in relObjRelOther)
        {
            var relobjrel = (XTUMLOOAofOOA.RelationshipClassRelationOfOOA)otherrel;
            var linkedOneTypeName = RuleOfNamesForTransfrom.GetMethodReturnType(relobjrel.RelationshipClass, relobjrel.RelationshipClass.OtherSideEdge.Mult);
            var linkedOneMethodName = RuleOfNamesForTransfrom.GetLinkedOOMethodName(relobjrel, RuleOfNamesForTransfrom.RelationshipEdgeSide.OneSide);
#>
        public <#= linkedOneTypeName #> <#= linkedOneMethodName #>()
        {
<#
            var logicGenerator = new LinkedItemLogic(logicIndent, relobjrel, relobjrel.OtherSideEdge, relobjrel.RelationshipClass.OtherSideEdge, null);
            var logic = logicGenerator.TransformText();
#>
<#= logic #>
        }
<#
        }

        if (classDef is XTUMLOOAofOOA.RelationshipClassOfOOA)
        {
            var relClassDef = (XTUMLOOAofOOA.RelationshipClassOfOOA)classDef;
            var linkedOneSideMethodName = RuleOfNamesForTransfrom.GetLinkedOOMethodName(relClassDef, RuleOfNamesForTransfrom.RelationshipEdgeSide.OneSide);
            var linkedOneSideReturnTypeName = RuleOfNamesForTransfrom.GetMethodReturnType(relClassDef.Relationship.OneSideEdge.Edge, XTUMLOOAofOOA.RelationshpEdgeOfOOA.Multiplicity.MULT_1);
#>
         public <#= linkedOneSideReturnTypeName #> <#= linkedOneSideMethodName #>()
         {
<#
            var currentMult = relClassDef.Relationship.OneSideEdge.Mult;
            relClassDef.Relationship.OneSideEdge.Mult = XTUMLOOAofOOA.RelationshpEdgeOfOOA.Multiplicity.MULT_1;
            var logicGeneratorOne = new LinkedItemLogic(logicIndent, relClassDef.Relationship, relClassDef.OneSideEdge, relClassDef.Relationship.OneSideEdge, null);
            var logicOne = logicGeneratorOne.TransformText();
            relClassDef.Relationship.OneSideEdge.Mult = currentMult;
#>
<#= logicOne #>
        }

<#

            var linkedOtherSideMethodName = RuleOfNamesForTransfrom.GetLinkedOOMethodName(relClassDef, RuleOfNamesForTransfrom.RelationshipEdgeSide.OtherSide);
            var linkedOtherSideReturnTypeName = RuleOfNamesForTransfrom.GetMethodReturnType(relClassDef.Relationship.OtherSideEdge.Edge, XTUMLOOAofOOA.RelationshpEdgeOfOOA.Multiplicity.MULT_1);
#>
        public <#= linkedOtherSideReturnTypeName #> <#= linkedOtherSideMethodName #>()
        {
<#
            currentMult = relClassDef.Relationship.OtherSideEdge.Mult;
            relClassDef.Relationship.OtherSideEdge.Mult = XTUMLOOAofOOA.RelationshpEdgeOfOOA.Multiplicity.MULT_1;
            var logicGeneratorOther = new LinkedItemLogic(logicIndent, relClassDef.Relationship, relClassDef.OtherSideEdge, relClassDef.Relationship.OtherSideEdge, null);
            var logicOther = logicGeneratorOther.TransformText();
            relClassDef.Relationship.OtherSideEdge.Mult = currentMult;
#>
<#= logicOther #>
        }

<#
        }
#>
    }
<#
    }
#>
}
